{#
  Card State Manager - Shared Alpine.js functionality for expandable cards
  
  Provides common Alpine.js data and methods for card interactions.
  Used by task_card, opportunity_card, and contact_card components.
  
  Parameters:
  - card_type (required): 'task' | 'opportunity' | 'contact'
  - entity_id (required): Unique ID of the entity
  - expansion_enabled (optional): Enable expansion functionality (default: true)
  - notes_enabled (optional): Enable notes/comments functionality (default: false)
  - group_key (optional): Group identifier for expand/collapse all events
  
  Usage:
  Include this in card templates and extend with entity-specific data:
  {{ card_state_manager('task', task.id, notes_enabled=true, group_key=section_key) }}
#}
{% macro card_state_manager(card_type, entity, entity_id, expansion_enabled=true, notes_enabled=false, group_key='') %}
x-data="{ 
    // Entity data
    {{ card_type }}: {{ entity | tojson if entity else '{}' }},
    
    // Core expansion state
    expanded: false,
    
    // Notes and comments (always define to prevent undefined errors)
    newComment: '',
    editingCommentId: null,
    editingCommentText: '',
    notes: [],
    notesLoaded: false,
    saving: false,
    show: false,
    
    // Generic editing state
    isEditing: false,
    showSaveButtons: false,
    
    {% if card_type == 'task' %}
    // Task-specific state
    pendingDays: 0,
    originalDueDate: '{{ entity.due_date.strftime('%d/%m/%y') if entity.due_date else '' }}',
    
    getNewDueDate() {
        if (!this.originalDueDate || this.pendingDays === 0) return this.originalDueDate;
        const date = new Date('{{ entity.due_date.isoformat() if entity.due_date else '' }}');
        date.setDate(date.getDate() + this.pendingDays);
        return date.toLocaleDateString('en-GB');
    },
    
    adjustDays(days) {
        this.pendingDays += days;
        this.isEditing = true;
        this.showSaveButtons = true;
    },
    
    cancelChanges() {
        this.pendingDays = 0;
        this.isEditing = false;
        this.showSaveButtons = false;
    },
    {% endif %}
    
    // Notes functionality (always define to prevent errors)
    async loadNotes() {
        {% if not notes_enabled %}return;{% endif %}
        if (this.notesLoaded) return;
        
        try {
            const response = await fetch(`/api/{{ card_type }}s/{{ entity_id }}/notes`);
            if (response.ok) {
                this.notes = await response.json();
                this.notesLoaded = true;
            } else {
                console.error('Failed to load notes');
            }
        } catch (error) {
            console.error('Error loading notes:', error);
        }
    },
    
    startEditComment(commentId, currentText) {
        {% if not notes_enabled %}return;{% endif %}
        this.editingCommentId = commentId;
        this.editingCommentText = currentText;
    },
    
    cancelEditComment() {
        {% if not notes_enabled %}return;{% endif %}
        this.editingCommentId = null;
        this.editingCommentText = '';
    },
    
    async saveEditComment() {
        {% if not notes_enabled %}return;{% endif %}
        if (!this.editingCommentText.trim()) return;
        
        try {
            const response = await fetch(`/api/notes/${this.editingCommentId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    content: this.editingCommentText
                })
            });
            
            if (response.ok) {
                const noteIndex = this.notes.findIndex(note => note.id === this.editingCommentId);
                if (noteIndex !== -1) {
                    this.notes[noteIndex].content = this.editingCommentText;
                }
                this.editingCommentId = null;
                this.editingCommentText = '';
            } else {
                alert('Failed to update comment');
            }
        } catch (error) {
            console.error('Error updating comment:', error);
            alert('Failed to update comment');
        }
    },
    
    async deleteComment(commentId) {
        {% if not notes_enabled %}return;{% endif %}
        if (!confirm('Are you sure you want to delete this comment?')) return;
        
        try {
            const response = await fetch(`/api/notes/${commentId}`, {
                method: 'DELETE'
            });
            
            if (response.ok) {
                this.notes = this.notes.filter(note => note.id !== commentId);
            } else {
                alert('Failed to delete comment');
            }
        } catch (error) {
            console.error('Error deleting comment:', error);
            alert('Failed to delete comment');
        }
    },
    
    async submitComment() {
        {% if not notes_enabled %}return;{% endif %}
        if (!this.newComment.trim()) return;
        
        try {
            const response = await fetch(`/api/{{ card_type }}s/{{ entity_id }}/notes`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    content: this.newComment,
                    is_internal: true
                })
            });
            
            if (response.ok) {
                const newNote = await response.json();
                if (!this.notes) this.notes = [];
                this.notes.unshift(newNote);
                this.newComment = '';
            } else {
                alert('Failed to add comment');
            }
        } catch (error) {
            console.error('Error adding comment:', error);
            alert('Failed to add comment');
        }
    }
}"
{% if expansion_enabled %}
@click="expanded = !expanded{% if notes_enabled %}; if (expanded) loadNotes(){% endif %}"
{% if group_key %}
@expand-all-{{ card_type }}s.window="if ($event.detail.group === '{{ group_key }}' && !expanded) { expanded = true{% if notes_enabled %}; loadNotes(){% endif %}; }"
@collapse-all-{{ card_type }}s.window="if ($event.detail.group === '{{ group_key }}' && expanded) { expanded = false; }"
{% endif %}
{% endif %}
{% if card_type == 'task' %}
@reschedule-saved.window="cancelChanges()"
{% endif %}
:class="{ 'ring-2 ring-blue-200 bg-blue-50': {% if expansion_enabled %}expanded || {% endif %}isEditing }"
{% endmacro %}

{#
  Expandable Content Section - Generic expandable content area
  
  Parameters:
  - content_type (required): Type of content ('notes', 'details', 'actions')
  - title (optional): Section title
  - content (required): Content to display (HTML)
  
  Usage:
  {% call expandable_content_section('notes', 'Comments & Notes') %}
    <!-- Notes content here -->
  {% endcall %}
#}
{% macro expandable_content_section(content_type, title='') %}
<div x-show="expanded" 
     x-transition:enter="transition ease-out duration-200"
     x-transition:enter-start="opacity-0 transform scale-95"
     x-transition:enter-end="opacity-100 transform scale-100"
     x-transition:leave="transition ease-in duration-150"
     x-transition:leave-start="opacity-100 transform scale-100"
     x-transition:leave-end="opacity-0 transform scale-95"
     class="mt-4 pt-4 border-t border-gray-100">
    {% if title %}
    <h4 class="text-sm font-medium text-gray-900 mb-3">{{ title }}</h4>
    {% endif %}
    {{ caller() }}
</div>
{% endmacro %}

{#
  Notes Section - Reusable notes/comments section
  
  Usage:
  {{ notes_section() }}
#}
{% macro notes_section() %}
<div class="space-y-3">
    <!-- Add Comment Form -->
    <div @click.stop>
        <textarea x-model="newComment"
                  placeholder="Add a comment..." 
                  class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm mb-2"
                  rows="2"></textarea>
        <button @click.stop="submitComment()"
                :disabled="!newComment.trim()"
                class="px-3 py-2 text-sm rounded transition-all duration-200"
                :class="newComment.trim() ? 'bg-blue-600 text-white hover:bg-blue-700' : 'bg-gray-200 text-gray-400 cursor-not-allowed'">
            Save
        </button>
    </div>
    
    <!-- Comments List -->
    <div class="space-y-2 max-h-48 overflow-y-auto">
        <template x-for="note in notes" :key="note.id">
            <div class="bg-gray-50 p-2 rounded text-sm">
                <div class="flex items-center justify-between mb-1">
                    <span class="text-xs-gray-500" x-text="new Date(note.created_at).toLocaleString()"></span>
                    <div class="flex items-center space-x-1">
                        <button @click.stop="startEditComment(note.id, note.content)" class="text-xs-gray-400 hover:text-gray-600">Edit</button>
                        <span class="text-xs-gray-300">|</span>
                        <button @click.stop="deleteComment(note.id)" class="text-xs-red-400 hover:text-red-600">Delete</button>
                    </div>
                </div>
                <div x-show="editingCommentId === note.id" @click.stop>
                    <textarea x-model="editingCommentText" class="w-full px-2 py-1 border border-gray-300 rounded text-sm mb-2" rows="2"></textarea>
                    <div class="flex space-x-2">
                        <button @click.stop="saveEditComment()" class="px-2 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700">Save</button>
                        <button @click.stop="cancelEditComment()" class="px-2 py-1 border border-gray-300 text-xs rounded hover:bg-gray-50">Cancel</button>
                    </div>
                </div>
                <p x-show="editingCommentId !== note.id" class="text-gray-700" x-text="note.content"></p>
            </div>
        </template>
        
        <div x-show="notes.length === 0" class="text-center text-gray-500 text-sm py-4">
            No comments yet. Add one above to get started.
        </div>
    </div>
</div>
{% endmacro %}